/**
 **  Macro to run the offline for all the detectors simultaneously
 **
 **  One needs to set up the Phase0 experiments, in this case s455
 **
 **  This macro takes the root files generated by the unpack_offline macro
 **  and processes the mapped data to get the next data levels (Cal and hit)
 **
 **  Author: Jose Luis <joseluis.rodriguez.sanchez@usc.es>
 **  @since May 4th, 2021
 **
 **  Modified: Gabriel Garcia <gabrielgarcia.jimenez@usc.es>
 **  @ October 7th, 2021
 **  const Int_t nev = -1; number of events to read, -1 - until CTRL+C
 **  Select experiment ID: 444, 467 or 455
 **
 **  After defining the input file (filename), execute the macro
 **  1) if all the parameters are right by default
 **     root -l cal_offline.C
 **  2) if one wants to select a RunId, for instance 'RunId = 273'
 **     root -l 'cal_offline.C(273)'
 **  3) if one wants to select a RunId and max number of events,
 **     for instance 'RunId = 273' and 'nev = 200'
 **     root -l 'cal_offline.C(273,200)'
 **  4) if one wants to select a RunId, max number of events and ExpId,
 **     for instance 'RunId = 273', 'nev = 200', and 'ExpId = 444'
 **     root -l 'cal_offline.C(273,200,444)'
 **  Points (2), (3) and (4) are used only if runid file (setup_runid.par) is
 *not defined
 **
 **/

struct metafile_data_struct {

  Int_t fRunID;
  Int_t fExpRun;
  int64_t fTimeStamp;

  Int_t califaMapVersion;
  Int_t califaCalVersion;
  Int_t califaGeoVersion;

  Int_t gladFieldVersion;

  Int_t mwpc0CalVersion;
  Int_t mwpc1CalVersion;
  Int_t mwpc2CalVersion;
  Int_t mwpc3CalVersion;

  Int_t mwpc0GeoVersion;
  Int_t mwpc1GeoVersion;
  Int_t mwpc2GeoVersion;
  Int_t mwpc3GeoVersion;

  Int_t trimGeoVersion;
  Int_t trimCalVersion;
  Int_t trimHitVersion;

  Int_t twimCalVersion;
  Int_t twimHitVersion;
  Int_t twimGeoVersion;

  Int_t targetGeoVersion;

  Int_t sciCalVersion;

  Int_t tofCalVersion;
  Int_t tofHitVersion;
  Int_t tofGeoVersion;

  Int_t amsCalVersion;
  Int_t amsMapVersion;
};

TString lookforfile();

void cal_offline(const Int_t fRunId = 1, const Int_t nev = -1,
                 const Int_t fExpId = 455) {
  TString cRunId = Form("%04d", fRunId);
  TString cExpId = Form("%03d", fExpId);

  TStopwatch timer;

  auto t = std::time(nullptr);
  auto tm = *std::localtime(&t);
  std::ostringstream oss;
  oss << std::put_time(&tm, "%Y%m%d_%H%M%S");

  // File names and paths -----------------------------------------------------
  TString dir = gSystem->Getenv("VMCWORKDIR");
  TString filename, outputFilename, upexps_dir, ucesb_path, sofiacaldir;

  if (fExpId == 455) {
    // Input file
    filename = "file_to_unpack";

    if (fRunId == 1 && nev == 100000) // This is for tests
      filename = lookforfile();

    TString outputpath = "/path/to/your/disk/";
    outputFilename = "output_file_name";

  } else {
    std::cout << "Experiment was not selected" << std::endl;
    gApplication->Terminate();
  }

  // store data or not ------------------------------------
  Bool_t fCal_level_califa =
      true; // set true if there exists a file with the calibration parameters

  // Setup: Selection of detectors
  // ----------------------------------------------------
  // --- R3B standard
  // -----------------------------------------------------------------
  Bool_t fNeuland = false; // NeuLAND for neutrons behind GLAD
  Bool_t fAms = false;     // AMS tracking detectors
  Bool_t fCalifa = true;   // Califa calorimeter
  Bool_t fMusic = false;   // R3B-Music: Ionization chamber for charge-Z
  // --- Sofia
  // ------------------------------------------------------------------------
  Bool_t fMwpc0 = false; // MWPC0 for tracking at entrance of Cave-C
  Bool_t fTrim =
      false; // Triple-MUSIC for the HI beam charge-Z id, with charge-q states
  Bool_t fAt = false;    // Active Targer for Coulomb-induced fission
  Bool_t fSci = false;   // Start: Plastic scintillator for ToF
  Bool_t fMwpc1 = false; // MWPC1 for tracking of fragments in front of target
  Bool_t fMwpc2 = false; // MWPC2 for tracking of fragments before GLAD
  Bool_t fTwim = false;  // Twim: Ionization chamber for charge-Z of fragments
  Bool_t fMwpc3 = false; // MWPC3 for tracking of fragments behind GLAD
  Bool_t fTofW = false;  // ToF-Wall for time-of-flight of fragments behind GLAD
  Bool_t fScalers = false; // SIS3820 scalers at Cave C
  // --- Traking
  // ----------------------------------------------------------------------
  Bool_t fTracking = false; // Tracking of fragments inside GLAD and before GLAD

  // Create run  --------------------------------------------------------------
  FairRunAna *run = new FairRunAna();
  // Set up R3BHeader  --------------------------------------------------------
  R3BEventHeader *EvntHeader = new R3BEventHeader();
  run->SetEventHeader(EvntHeader);
  run->SetRunId(fRunId);
  run->SetSink(new FairRootFileSink(outputFilename));

  // Runtime data base ------------------------------------
  FairRuntimeDb *rtdb = run->GetRuntimeDb();

  /* ------------- Set Parameter File ----------------*/

  TString calibrationFile = "../../../s455_expParams.root";
  calibrationFile.ReplaceAll("//", "/");

  /* -------------- Set Parameter Containers ---------- */
  R3BCalifaCrystalCalPar *califaCalPar;
  R3BCalifaMappingPar *califaMapPar;
  R3BTGeoPar *califaGeoPar;

  R3BSofGladFieldPar *gladFieldPar;

  R3BSofMwpc0CalPar *mwpc0CalPar;
  R3BSofMwpc1CalPar *mwpc1CalPar;
  R3BSofMwpc2CalPar *mwpc2CalPar;
  R3BSofMwpc3CalPar *mwpc3CalPar;
  R3BTGeoPar *mwpc0GeoPar;
  R3BTGeoPar *mwpc1GeoPar;
  R3BTGeoPar *mwpc2GeoPar;
  R3BTGeoPar *mwpc3GeoPar;

  R3BTGeoPar *trimGeoPar;
  R3BSofTrimCalPar *trimCalPar;
  R3BSofTrimHitPar *trimHitPar;

  R3BSofTwimCalPar *twimCalPar;
  R3BSofTwimHitPar *twimHitPar;
  R3BTGeoPar *twimGeoPar;

  R3BTGeoPar *targetGeoPar;

  R3BSofSciMapped2TcalPar *sciTCalPar;
  R3BSofSciRawTofPar *sciRawTofPar;
  R3BSofSciCalPosPar *sciCalPosPar;
  R3BSofSciCalTofPar *sciCalTofPar;

  R3BSofTofWMapped2TcalPar *tofTCalPar;
  R3BSofTofWHitPar *tofHitPar;
  R3BTGeoPar *tofGeoPar;

  R3BAmsStripCalPar *amsStripCalPar;
  R3BAmsMappingPar *amsMapPar;

  FairParRootFileIo *parIo1 = new FairParRootFileIo(kFALSE);

  califaCalPar =
      (R3BCalifaCrystalCalPar *)rtdb->getContainer("califaCrystalCalPar");
  califaMapPar = (R3BCalifaMappingPar *)rtdb->getContainer("califaMappingPar");
  califaGeoPar = (R3BTGeoPar *)rtdb->getContainer("CalifaGeoPar");

  gladFieldPar = (R3BSofGladFieldPar *)rtdb->getContainer("GladFieldPar");

  mwpc0CalPar = (R3BSofMwpc0CalPar *)rtdb->getContainer("mwpc0CalPar");
  mwpc1CalPar = (R3BSofMwpc1CalPar *)rtdb->getContainer("mwpc1CalPar");
  mwpc2CalPar = (R3BSofMwpc2CalPar *)rtdb->getContainer("mwpc2CalPar");
  mwpc3CalPar = (R3BSofMwpc3CalPar *)rtdb->getContainer("mwpc3CalPar");

  mwpc0GeoPar = (R3BTGeoPar *)rtdb->getContainer("Mwpc0GeoPar");
  mwpc1GeoPar = (R3BTGeoPar *)rtdb->getContainer("Mwpc1GeoPar");
  mwpc2GeoPar = (R3BTGeoPar *)rtdb->getContainer("Mwpc2GeoPar");
  mwpc3GeoPar = (R3BTGeoPar *)rtdb->getContainer("Mwpc3GeoPar");

  trimGeoPar = (R3BTGeoPar *)rtdb->getContainer("TrimGeoPar");
  trimHitPar = (R3BSofTrimHitPar *)rtdb->getContainer("trimHitPar");
  trimCalPar = (R3BSofTrimCalPar *)rtdb->getContainer("trimCalPar");

  twimCalPar = (R3BSofTwimCalPar *)rtdb->getContainer("twimCalPar");
  twimHitPar = (R3BSofTwimHitPar *)rtdb->getContainer("twimHitPar");
  twimGeoPar = (R3BTGeoPar *)rtdb->getContainer("TwimGeoPar");

  targetGeoPar = (R3BTGeoPar *)rtdb->getContainer("TargetGeoPar");

  sciTCalPar = (R3BSofSciMapped2TcalPar *)rtdb->getContainer("SofSciTcalPar");
  sciRawTofPar = (R3BSofSciRawTofPar *)rtdb->getContainer("SofSciRawTofPar");
  sciCalPosPar = (R3BSofSciCalPosPar *)rtdb->getContainer("SofSciCalPosPar");
  sciCalTofPar = (R3BSofSciCalTofPar *)rtdb->getContainer("SofSciCalTofPar");

  tofTCalPar = (R3BSofTofWMapped2TcalPar *)rtdb->getContainer("SofTofWTcalPar");
  tofGeoPar = (R3BTGeoPar *)rtdb->getContainer("TofwGeoPar");
  tofHitPar = (R3BSofTofWHitPar *)rtdb->getContainer("tofwHitPar");

  amsMapPar = (R3BAmsMappingPar *)rtdb->getContainer("amsMappingPar");
  amsStripCalPar = (R3BAmsStripCalPar *)rtdb->getContainer("amsStripCalPar");

  parIo1->open(calibrationFile, "in");
  rtdb->setFirstInput(parIo1);

  parIo1->open(calibrationFile);
  rtdb->setFirstInput(parIo1);
  rtdb->print();

  // Create source using root files for input ---------------------------------
  R3BFileSource *source = new R3BFileSource(filename);
  source->SetInputFileName("../parameters/setup_runid.par");
  source->SetRunId(fRunId);
  run->SetSource(source);

  /* ------------ Setting Parameter Information ------------- */

  std::vector<metafile_data_struct> metafileEntries;
  Int_t lines = 0;

  struct metafile_data_struct metaElem;

  ifstream *metafile = new ifstream("../../../metafile.csv");

  while (!metafile->eof() && lines < 2) {

    *metafile >> hex >> metaElem.fRunID >> metaElem.fExpRun >>
        metaElem.fTimeStamp >> metaElem.califaMapVersion >>
        metaElem.califaCalVersion >> metaElem.califaGeoVersion >>
        metaElem.gladFieldVersion >> metaElem.mwpc0CalVersion >>
        metaElem.mwpc1CalVersion >> metaElem.mwpc2CalVersion >>
        metaElem.mwpc3CalVersion >> metaElem.mwpc0GeoVersion >>
        metaElem.mwpc1GeoVersion >> metaElem.mwpc2GeoVersion >>
        metaElem.mwpc3GeoVersion >> metaElem.trimCalVersion >>
        metaElem.trimHitVersion >> metaElem.trimGeoVersion >>
        metaElem.twimCalVersion >> metaElem.twimHitVersion >>
        metaElem.twimGeoVersion >> metaElem.targetGeoVersion >>
        metaElem.sciCalVersion >> metaElem.tofCalVersion >>
        metaElem.tofHitVersion >> metaElem.tofGeoVersion >>
        metaElem.amsMapVersion >> metaElem.amsCalVersion;
    metafileEntries.push_back(metaElem);
    lines++;
  }

  metafile->close();

  Int_t fRunID;
  Int_t fCalifaCalVersion, fCalifaMapVersion, fCalifaGeoVersion;
  Int_t fGladFieldVersion;
  Int_t fMwpc0CalVersion, fMwpc1CalVersion, fMwpc2CalVersion, fMwpc3CalVersion;
  Int_t fMwpc0GeoVersion, fMwpc1GeoVersion, fMwpc2GeoVersion, fMwpc3GeoVersion;
  Int_t fTrimGeoVersion, fTrimCalVersion, fTrimHitVersion;
  Int_t fTwimCalVersion, fTwimHitVersion, fTwimGeoVersion;
  Int_t fTargetGeoVersion;
  Int_t fSciCalVersion;
  Int_t fTofCalVersion, fTofHitVersion, fTofGeoVersion;
  Int_t fAmsMapVersion, fAmsCalVersion;

  for (Int_t i = 0; i < metafileEntries.size(); i++) {

    fRunID = metafileEntries.at(i).fRunID;

    fCalifaMapVersion = metafileEntries.at(i).califaMapVersion;
    fCalifaCalVersion = metafileEntries.at(i).califaCalVersion;
    fCalifaGeoVersion = metafileEntries.at(i).califaGeoVersion;

    fGladFieldVersion = metafileEntries.at(i).gladFieldVersion;
    fMwpc0CalVersion = metafileEntries.at(i).mwpc0CalVersion;
    fMwpc1CalVersion = metafileEntries.at(i).mwpc1CalVersion;
    fMwpc2CalVersion = metafileEntries.at(i).mwpc2CalVersion;
    fMwpc3CalVersion = metafileEntries.at(i).mwpc3CalVersion;

    fMwpc0GeoVersion = metafileEntries.at(i).mwpc0GeoVersion;
    fMwpc1GeoVersion = metafileEntries.at(i).mwpc1GeoVersion;
    fMwpc2GeoVersion = metafileEntries.at(i).mwpc2GeoVersion;
    fMwpc3GeoVersion = metafileEntries.at(i).mwpc3GeoVersion;

    fTrimCalVersion = metafileEntries.at(i).trimCalVersion;
    fTrimGeoVersion = metafileEntries.at(i).trimGeoVersion;
    fTrimHitVersion = metafileEntries.at(i).trimHitVersion;

    fTwimCalVersion = metafileEntries.at(i).trimCalVersion;
    fTwimHitVersion = metafileEntries.at(i).trimHitVersion;
    fTwimGeoVersion = metafileEntries.at(i).trimGeoVersion;
    fTargetGeoVersion = metafileEntries.at(i).targetGeoVersion;

    fSciCalVersion = metafileEntries.at(i).sciCalVersion;

    fTofCalVersion = metafileEntries.at(i).tofCalVersion;
    fTofHitVersion = metafileEntries.at(i).tofHitVersion;
    fTofGeoVersion = metafileEntries.at(i).tofGeoVersion;

    fAmsMapVersion = metafileEntries.at(i).amsMapVersion;
    fAmsCalVersion = metafileEntries.at(i).amsCalVersion;

    rtdb->addRun(fRunID);

    rtdb->setInputVersion(fRunID, (char *)"califaCrystalCalPar",
                          fCalifaCalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"califaMappingPar", fCalifaMapVersion,
                          1);
    rtdb->setInputVersion(fRunID, (char *)"CalifaGeoPar", fCalifaGeoVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"GladFieldPar", fGladFieldVersion, 1);

    rtdb->setInputVersion(fRunID, (char *)"mwpc0CalPar", fMwpc0CalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"mwpc1CalPar", fMwpc1CalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"mwpc2CalPar", fMwpc2CalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"mwpc3CalPar", fMwpc3CalVersion, 1);

    rtdb->setInputVersion(fRunID, (char *)"Mwpc0GeoPar", fMwpc0GeoVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"Mwpc1GeoPar", fMwpc1GeoVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"Mwpc2GeoPar", fMwpc2GeoVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"Mwpc3GeoPar", fMwpc3GeoVersion, 1);

    rtdb->setInputVersion(fRunID, (char *)"trimCalPar", fTrimCalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"trimHitPar", fTrimHitVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"TrimGeoPar", fTrimGeoVersion, 1);

    rtdb->setInputVersion(fRunID, (char *)"twimCalPar", fTwimCalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"twimHitPar", fTwimHitVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"TwimGeoPar", fTwimGeoVersion, 1);

    rtdb->setInputVersion(fRunID, (char *)"TargetGeoPar", fTargetGeoVersion, 1);

    rtdb->setInputVersion(fRunID, (char *)"SofSciTcalPar", fSciCalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"SofSciRawTofPar", fSciCalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"SofSciCalPosPar", fSciCalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"SofSciCalTofPar", fSciCalVersion, 1);

    rtdb->setInputVersion(fRunID, (char *)"SofTofWTcalPar", fTofCalVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"tofwHitPar", fTofHitVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"TofwGeoPar", fTofGeoVersion, 1);

    rtdb->setInputVersion(fRunID, (char *)"amsMappingPar", fAmsMapVersion, 1);
    rtdb->setInputVersion(fRunID, (char *)"amsStripCalPar", fAmsCalVersion, 1);

    rtdb->initContainers(fRunID);
    rtdb->Print();
  }

  // Add analysis task --------------------------------------------------------

  // Add Header copy
  R3BEventHeaderPropagator *RunIdTask = new R3BEventHeaderPropagator();
  run->AddTask(RunIdTask);

  // Add WRs from sofia
  R3BWhiterabbitPropagator *wrsofia =
      new R3BWhiterabbitPropagator("SofWhiterabbitPropagator", 1, "SofWR");
  run->AddTask(wrsofia);

  // MWPC0
  if (fMwpc0) {
    R3BSofMwpc0Mapped2Cal *MW0Map2Cal = new R3BSofMwpc0Mapped2Cal();
    run->AddTask(MW0Map2Cal);

    R3BSofMwpc0Cal2Hit *MW0Cal2Hit = new R3BSofMwpc0Cal2Hit();
    run->AddTask(MW0Cal2Hit);
  }

  // SCI
  if (fSci) {
    // --- Mapped 2 Tcal for SofSci
    R3BSofSciMapped2Tcal *SofSciMap2Tcal = new R3BSofSciMapped2Tcal();
    run->AddTask(SofSciMap2Tcal);

    // --- Tcal 2 SingleTcal for SofSci
    R3BSofSciTcal2SingleTcal *SofSciTcal2STcal = new R3BSofSciTcal2SingleTcal();
    run->AddTask(SofSciTcal2STcal);

    // --- SingleTcal 2 Cal for SofSci
    R3BSofSciSingleTcal2Cal *SofSciSTcal2Cal = new R3BSofSciSingleTcal2Cal();
    run->AddTask(SofSciSTcal2Cal);

    // --- SingleTcal 2 Hit for SofSci
    R3BSofSciSingleTcal2Hit *SofSciSTcal2Hit = new R3BSofSciSingleTcal2Hit();
    SofSciSTcal2Hit->SetCalParams(675., -1922.); // ToF calibration at Cave-C
    run->AddTask(SofSciSTcal2Hit);
  }

  // Triple-MUSIC
  if (fTrim) {
    // --- Mapped 2 Cal
    R3BSofTrimMapped2Cal *SofTrimMap2Cal = new R3BSofTrimMapped2Cal();
    run->AddTask(SofTrimMap2Cal);

    // --- Cal 2 Hit
    R3BSofTrimCal2Hit *SofTrimCal2Hit = new R3BSofTrimCal2Hit();
    SofTrimCal2Hit->SetExpId(fExpId);
    SofTrimCal2Hit->SetCoulex(kFALSE);
    SofTrimCal2Hit->SetTriShape(kTRUE);
    run->AddTask(SofTrimCal2Hit);
  }

  // AMS
  if (fAms) {
    // R3BWhiterabbitPropagator ---
    R3BWhiterabbitPropagator *wrams =
        new R3BWhiterabbitPropagator("AmsWhiterabbitPropagator", 1, "WRAms");
    run->AddTask(wrams);
    R3BAmsMapped2StripCal *AmsMap2Cal = new R3BAmsMapped2StripCal();
    run->AddTask(AmsMap2Cal);
    R3BAmsStripCal2Hit *AmsCal2Hit = new R3BAmsStripCal2Hit();
    run->AddTask(AmsCal2Hit);
  }

  // CALIFA
  if (fCalifa && fCal_level_califa) {
    // R3BWhiterabbitPropagator ---
    R3BWhiterabbitPropagator *wrcalifa = new R3BWhiterabbitPropagator(
        "CalifaWhiterabbitPropagator", 1, "WRCalifa");
    run->AddTask(wrcalifa);
    // R3BCalifaMapped2CrystalCal ---
    R3BCalifaMapped2CrystalCal *CalifaMap2Cal =
        new R3BCalifaMapped2CrystalCal();
    run->AddTask(CalifaMap2Cal);
    // R3BCalifaCrystalCal2Hit ---
    R3BCalifaCrystalCal2Hit *CalifaCal2Hit = new R3BCalifaCrystalCal2Hit();
    CalifaCal2Hit->SetCrystalThreshold(15000.); // 100keV
    CalifaCal2Hit->SetDRThreshold(20000.);      // 10MeV
    CalifaCal2Hit->SelectGeometryVersion(2021);
    CalifaCal2Hit->SetSquareWindowAlg(0.25, 0.25);

    run->AddTask(CalifaCal2Hit);
  }

  // MWPC1
  if (fMwpc1) {
    R3BSofMwpc1Mapped2Cal *MW1Map2Cal = new R3BSofMwpc1Mapped2Cal();
    run->AddTask(MW1Map2Cal);

    R3BSofMwpc1Cal2Hit *MW1Cal2Hit = new R3BSofMwpc1Cal2Hit();
    run->AddTask(MW1Cal2Hit);
  }

  // MWPC2
  if (fMwpc2) {
    R3BSofMwpc2Mapped2Cal *MW2Map2Cal = new R3BSofMwpc2Mapped2Cal();
    run->AddTask(MW2Map2Cal);

    R3BSofMwpc2Cal2Hit *MW2Cal2Hit = new R3BSofMwpc2Cal2Hit();
    run->AddTask(MW2Cal2Hit);
  }

  // MWPC3
  if (fMwpc3) {
    R3BSofMwpc3Mapped2Cal *MW3Map2Cal = new R3BSofMwpc3Mapped2Cal();
    run->AddTask(MW3Map2Cal);

    R3BSofMwpc3Cal2Hit *MW3Cal2Hit = new R3BSofMwpc3Cal2Hit();
    run->AddTask(MW3Cal2Hit);
  }

  // ToF-Wall
  if (fTofW) {
    // --- Mapped 2 Tcal for SofTofW
    R3BSofTofWMapped2Tcal *SofTofWMap2Tcal = new R3BSofTofWMapped2Tcal();
    run->AddTask(SofTofWMap2Tcal);

    // --- Tcal 2 SingleTcal for SofTofW
    R3BSofTofWTcal2SingleTcal *SofTofWTcal2STcal =
        new R3BSofTofWTcal2SingleTcal();
    run->AddTask(SofTofWTcal2STcal);

    // --- SingleTcal 2 Hit for SofTofW
    R3BSofTofWSingleTCal2Hit *SofTofWSingleTcal2Hit =
        new R3BSofTofWSingleTCal2Hit();
    SofTofWSingleTcal2Hit->SetExpId(fExpId);
    SofTofWSingleTcal2Hit->SetTofLISE(33.);
    run->AddTask(SofTofWSingleTcal2Hit);
  }

  // TWIM
  if (fTwim) {
    R3BSofTwimMapped2Cal *TwimMap2Cal = new R3BSofTwimMapped2Cal();
    TwimMap2Cal->SetExpId(fExpId);
    run->AddTask(TwimMap2Cal);

    R3BSofTwimCal2Hit *TwimCal2Hit = new R3BSofTwimCal2Hit();
    TwimCal2Hit->SetExpId(fExpId);
    run->AddTask(TwimCal2Hit);
  }

  // Tracking
  if (fMwpc2 && fMwpc3 && fTofW && fTwim && fSci && fTracking) {
    R3BSofFissionAnalysis *TrackingAna = new R3BSofFissionAnalysis();
    run->AddTask(TrackingAna);
  }

  // Initialize -------------------------------------------
  timer.Start();
  run->Init();
  FairLogger::GetLogger()->SetLogScreenLevel("INFO");

  // Run --------------------------------------------------
  if (nev > -1)
    run->Run(nev);
  else
    run->Run();

  // Finish -----------------------------------------------
  timer.Stop();
  Double_t rtime = timer.RealTime() / 60.;
  Double_t ctime = timer.CpuTime() / 60.;
  std::cout << std::endl << std::endl;
  std::cout << "Macro finished succesfully." << std::endl;
  std::cout << "Output file is " << outputFilename << std::endl;
  std::cout << "Real time " << rtime << " min, CPU time " << ctime << " min"
            << std::endl
            << std::endl;
  gApplication->Terminate();
}

TString lookforfile() {
  // This looks for root files in a directory defined below:
  TString directory = "./";

  TString filename;
  TString base = "s455_map_data_offline_([0-9]+)_([0-9]*)\\.root";

  TPRegexp regexp(base);

  std::cout << "Base: " << base << std::endl;
  std::cout << "Looking for datafiles in " << directory << std::endl;
  void *dirp = gSystem->OpenDirectory(directory);
  Char_t *afile;
  while ((afile = const_cast<Char_t *>(gSystem->GetDirEntry(dirp)))) {
    TObjArray *objArray = regexp.MatchS(afile);
    if (objArray->At(0)) { // match
      filename = directory + ((TObjString *)objArray->At(0))->GetString();
      std::cout << "Filename: " << filename << std::endl;
    }
    delete objArray;
  }
  return filename;
}
